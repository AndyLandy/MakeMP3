#!/usr/bin/env perl
##########
# 
# MakeMP3
# 
# A tool for creating MP3 files from lossless full-disc rips with cue sheets.
# Copyright 2015-2017 Andrew Paul Landells.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
# 
##########
use strict;
use warnings;
use Getopt::Long;
use Data::Dumper;
use Path::Class;

##########
# Global configuration
my $FFMPEG = 'ffmpeg';
my $FFMPEGOPTS = '-c:a pcm_s32le -f wav';
my $FFMPEGFILTER = '-af aemphasis=type=cd';
my $LAME = 'lame';
my $LAMEOPTS = '--preset extreme -k';
#my $FDKAAC = 'LD_LIBRARY_PATH=/opt/fdk-aac/lib /opt/fdkaac/bin/fdkaac';
my $FDKAAC = 'fdkaac';
my $FDKAACOPTS = '-p 2 -m 1 -w 22050';
my $GAIN = 'aacgain';
my $AGOPTS = '-a -c';
my $TGOPTS = '-r -c';
my $DESTDIR = 'makemp3';
my $VER = '1.3.0';

##########
# option variables with default value (false)
my $AG = '';
my $TG = '';
my $DEBUG = ''; 
my $DRY_RUN = ''; 
my $HELP = '';
my $VERSION = '';
my $AAC = '';

GetOptions (
    'debug'   => \$DEBUG,
    'dry-run' => \$DRY_RUN,
    'ag'      => \$AG,
    'tg'      => \$TG,
    'help'    => \$HELP,
    'version' => \$VERSION,
    'aac'     => \$AAC,
);

if ($VERSION) { print <<END;
MakeMP3 $VER
Copyright 2015-2017 Andrew Paul Landells

License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
END
; exit 0 }

if ($HELP) { print <<END;
Usage: $0 [--ag] [--tg] [--debug] [--dry-run] source_file ...
END
; exit 0 }


foreach (@ARGV) {
    # Cache the path to the cuesheet, since everything else is relative to it.
    my ($cuepath, $cuefile) = &split_path($_);

    # Read cuesheet and build data structure
    my $cuesheet = &parse_cuesheet(file($cuepath, $cuefile));
    print "Failed to open $_\n" and next unless defined $cuesheet;
    print Dumper $cuesheet if $DEBUG;

    my @tracks;
    print "$cuesheet->{PERFORMER} - " if defined $cuesheet->{PERFORMER};
    print "$cuesheet->{TITLE}:" if defined $cuesheet->{TITLE};
    print "\n";
    for (my $file = 0 ; $file <= $#{$cuesheet->{FILE}} ; $file++) {
        for (my $track = 0 ; $track <= $#{$cuesheet->{FILE}->[$file]->{TRACKS}} ; $track++) {
            # Create a correctly-formatted track number
            my $tn = &track_num($cuesheet, $file, $track);

            # Check to see if we're being asked to skip this track
            my $skip = &meta_override($cuesheet, "SKIP", $file, $track);
            print "... Track $tn skipped!\n" and next if defined ($skip) && $skip =~ /TRUE/i;

            # Create destination directory structure for output file
            my $destpath = file( $DESTDIR, &sanitise_filename($cuesheet->{PERFORMER}), &sanitise_filename($cuesheet->{TITLE}) );
            my $mkdir = "mkdir -p \"$destpath\"";

            # Create filename for the output file
            my $ip = file( $cuepath, $cuesheet->{FILE}->[$file]->{FILE}); # Input path = path + input file.
            my $title = &sanitise_filename("$tn ".&meta_override($cuesheet, 'TITLE', $file, $track));
            my $dest = file ( $destpath."/".$title );

            # Build metadata hash
            my %metadata = &get_metadata($cuesheet, $cuepath, $cuefile, $file, $track);

            # Build ffmpeg command line.
            my $ffmpegtimes = &get_ffmpegtimes($cuesheet, $file, $track);
            my $pre = $cuesheet->{FILE}->[$file]->{TRACKS}->[$track]->{FLAGS}->{PRE}; 
            my $af  = '';
               $af  = $FFMPEGFILTER if (defined $pre && $pre =~ m/TRUE/);
            my $ff  = "$FFMPEG -v warning -i \"$ip\" $ffmpegtimes $af $FFMPEGOPTS -";

            # Build encoder command line.
            my $enc;
            if ($AAC) {
                $dest .= '.m4a';
                $enc = &enc_fdkaac($dest, %metadata);
            } else {
                $dest .= '.mp3';
                $enc = &enc_lame($dest, %metadata);
            }

            # Build full command line.
            my $cmd = "$ff | $enc";
            $cmd .= " 2>&1 >/dev/null" unless ($DEBUG);
            push (@tracks, "\"$dest\"");

            # Run the commands
            print "... $title\n";
            &sys_cmd ($mkdir);
            &sys_cmd ($cmd);
        }
    }
    if ($AG or $TG) {
        my ($gainword, $gainopts)  =  $TG ? ('track', $TGOPTS) : ('album', $AGOPTS);
        my $gaincmd = "$GAIN -q $gainopts ".join (' ',@tracks);
        $gaincmd .= " 2>&1 >/dev/null" unless ($DEBUG);

        print "*** Applying $gainword gain\n";
        &sys_cmd ($gaincmd);
    }
}

##########
# Abstract out all system calls to a handler function that supports
# signal-handling. As a bonus, we can also collapse dryrun and debug
# behaviour to this one function.
#
# NB: Many commands will be invoked via a shell, rather than directly.
# This means the returncodes will be from bash, not the child process.
# As such, expect ^C to return an exit code of 130 but no evidence of a signal.
sub sys_cmd {
    my ($cmd) = @_;
    print "\tExecuting command: $cmd\n" if $DEBUG;
    system ($cmd) unless $DRY_RUN;
    if ($?) {
        # We got back a returncode that wasn't zero...

        my $exit = $? >>  8; # Top eight bits are the return code
        my $core = $? & 128; # Bit 8 is core dump (true/false)
        my $kill = $? & 127; # Bits 1-7 are the kill signal received

        my $error = "$cmd exited with returncode $exit";
        $error   .= ", killed with signal $kill" if ($kill);
        $error   .= ", core dumped" if ($core);
        warn ($error);

        # If the child process was killed with a signal, we exit too.
        # We exit with a returncode of SIG+128, just like bash does.
        exit ($kill + 128) if ($kill); # The child process was killed.
        exit ($exit) if ($exit > 128 && $exit < 255); # A grandchild was killed, so bash told us.

        # If we died by some other means, return the exit status but keep going!
        return $exit;
    }
    # Otherwise everything was fine!
    return 0;
}

##########
# Take the path to the cuesheet and split it into path and file.
# If it's in the current directory, use ./ as the path.
sub split_path {
    my ($cuepath, $cuefile);
    if (m/^(.*)[\\\/](.*?)$/) {
        ($cuepath, $cuefile) = ($1, $2);
    } else {
        $cuepath = "./";
        $cuefile = $_;
    }
    print "Path: $cuepath\nFile: $cuefile\n\n" if $DEBUG;
    return ($cuepath, $cuefile);
}

##########
# Create the human-readable track number for filenames.
# For single-disc sets, this will be of the form 01, 02, 03 ...
# For multi-disc sets, this will be of the form 1-01, 1-02 ... 2-01, 2-02 ...
# If no track metadata exists, just do without a prefix.
sub track_num {
    my ($cuesheet, $file, $track) = @_;
    my $tn = '';
    $tn .= $cuesheet->{DISCNUMBER}."-" if (defined $cuesheet->{DISCNUMBER} && defined $cuesheet->{TOTALDISCS} && $cuesheet->{TOTALDISCS} > 1);
    $tn .= sprintf("%.02d",&meta_override($cuesheet, 'TRACK', $file, $track));
    return $tn;
}

##########
sub get_metadata {
    my ($cuesheet, $cuepath, $cuefile, $file, $track) = @_;
    my %m;

    $m{encoder} = "MakeMP3 $VER";
    $m{albumt}  = &meta_override($cuesheet, "TITLE"                     );
    $m{albuma}  = &meta_override($cuesheet, "PERFORMER"                 );
    $m{trackt}  = &meta_override($cuesheet, "TITLE",      $file, $track );
    $m{tracka}  = &meta_override($cuesheet, "PERFORMER",  $file, $track );
    $m{genre}   = &meta_override($cuesheet, "GENRE",      $file, $track );
    $m{date}    = &meta_override($cuesheet, "DATE",       $file, $track );
    $m{comment} = &meta_override($cuesheet, "COMMENT",    $file, $track );
    $m{writer}  = &meta_override($cuesheet, "SONGWRITER", $file, $track );
    $m{tn}      = &meta_override($cuesheet, "TRACK",      $file, $track );
    $m{tt}      = &meta_override($cuesheet, "TOTAL_TRACKS",             );

    my $artwork = &meta_override($cuesheet, "ARTWORK",    $file, $track );
    $m{artwork} = file($cuepath, $artwork) if (defined $artwork);

    my $comp    = &meta_override($cuesheet, "COMPILATION");
    $m{comp}    = 0;
    $m{comp}    = 1 if (defined $comp && $comp =~ m/TRUE/);

    $m{dn}      = 1; 
    $m{dn}      = $cuesheet->{DISCNUMBER} if defined $cuesheet->{DISCNUMBER};
    $m{td}      = $m{dn};
    $m{td}      = $cuesheet->{TOTALDISCS} if defined $cuesheet->{TOTALDISCS};

    # Any missing metadata we set as the empty string.
    foreach my $k (keys %m) { $m{$k} = "" unless defined $m{$k}; }

    return %m;
}

##########
sub enc_fdkaac {
    my ($dest, %m) = @_;
    my $ART = "";
       $ART = "--tag-from-file covr:\"$m{artwork}\"" if (defined $m{artwork});
    my $cmd = <<END;
$FDKAAC $FDKAACOPTS -S
--tag            enc:"$m{encoder} / fdkaac $FDKAACOPTS"
--title         "$m{trackt}"
--artist        "$m{tracka}"
--album         "$m{albumt}"
--album-artist  "$m{albuma}"
--genre         "$m{genre}"
--date          "$m{date}"
--composer      "$m{writer}"
--comment       "$m{comment}"
--track         "$m{tn}/$m{tt}"
--disk          "$m{dn}/$m{td}"
--tag           cpil:$m{comp}
$ART
- -o "$dest"
END
    ;
    $cmd =~ s/\n/ /g;
    return $cmd;
}

##########
sub enc_lame {
    my ($dest, %m) = @_;
    my $ART = "";
       $ART = "--ti \"$m{artwork}\"" if (defined $m{artwork});
    my $cmd = <<END;
$LAME $LAMEOPTS
--id3v2-only --ignore-tag-errors
--tv TENC="$m{encoder} / lame $LAMEOPTS"
--tn $m{tn}/$m{tt}
--tv TPOS=$m{dn}/$m{td}
--tv TCMP=$m{comp}
--tl "$m{albumt}"
--tv TPE2="$m{albuma}"
--tt "$m{trackt}"
--ta "$m{tracka}"
--tg "$m{genre}"
--ty "$m{date}"
--tc "$m{comment}"
--tv TCOM="$m{writer}"
$ART
- "$dest"
END
    ;
    $cmd =~ s/\n/ /g;
    return $cmd;
}

##########
sub meta_override {
    my ($cuesheet, $field, $file, $track) = @_;
    return $cuesheet->{FILE}->[$file]->{TRACKS}->[$track]->{$field} if (defined $file) and (defined $track) and (defined $cuesheet->{FILE}->[$file]->{TRACKS}->[$track]->{$field});
    return $cuesheet->{$field} if defined $cuesheet->{$field};
    return undef;
}

##########
sub convert_time {
    # CD timestamps are of the form minutes:seconds:frames
    # where frames are 1/75th of a second.
    # ffmpeg timestamps are decimal seconds to arbitrary precision.
    my ($time) = @_;
    if (defined $time && $time =~ m/.*:.*:.*/) {
        my ($m, $s, $f) = split /:/,$time;
        return ($m * 60) + $s + ($f / 75);
    }
    return undef;
}

##########
sub get_time_index {
    my ($cuesheet, $file, $track, $index) = @_;
    if (defined $cuesheet->{FILE}->[$file]->{TRACKS}->[$track]) {
        return &convert_time($cuesheet->{FILE}->[$file]->{TRACKS}->[$track]->{INDEX}->[$index]);
    }
    return undef;
}

##########
sub get_ffmpegtimes {
    my ($cuesheet, $file, $track) = @_;
    my $this = &get_time_index($cuesheet, $file, $track,   1);
    my $stop = &convert_time($cuesheet->{FILE}->[$file]->{TRACKS}->[$track]->{END});
    my $next = &get_time_index($cuesheet, $file, $track+1, 1);
    my $ss = '';
    my $t  = '';
    if (defined $this) {
        $ss .= "-ss $this";
        if (defined $stop) {
            my $time = $stop - $this;
            $t .= "-t $time";
        } elsif (defined $next) {
            my $time = $next - $this;
            $t .= "-t $time";
        }
    }
    return ("$ss $t");
}

##########
sub parse_cuesheet {
    my ($cuesheet) = @_;
    open(my $fh, "<".$cuesheet) or return undef;
    my @cuesheet;
    while (<$fh>) {
        s/\r//g;
        s/\n//g;
        push @cuesheet, $_;
    }
    close ($fh);
    @cuesheet = &fix_noncompliant(@cuesheet);

    my $data = {};
    my $file = -1;
    my $track = -1;
    my $ttracks = 0;

    for (my $i = 0 ; $i <= $#cuesheet ; $i++) {
        if ($cuesheet[$i] =~ m/^\s*FILE "(.*)" (\w+)/) {
            $file++;
            $data->{FILE}->[$file]->{FILE} = $1;
            $data->{FILE}->[$file]->{TYPE} = $2;
            $track = -1;
            next;
        }
        if ($cuesheet[$i] =~ m/^\s*TRACK (\d+) AUDIO/) {
            $track++;
            $data->{FILE}->[$file]->{TRACKS}->[$track]->{TRACK} = $1;
            $ttracks = $1 if ($1 > $ttracks);
            next;
        }
        if ($cuesheet[$i] =~ m/^\s*INDEX (\d+) (.*)$/) {
            next if $track < 0; # Dodgy cue sheets may cause -1 indices.
            $data->{FILE}->[$file]->{TRACKS}->[$track]->{INDEX}->[$1] = $2;
            next;
        }

        if ($cuesheet[$i] =~ m/^\s*FLAGS (.*)/) {
            foreach my $flag (split /\s+/,$1) {
                $data->{FILE}->[$file]->{TRACKS}->[$track]->{FLAGS}->{$flag} = 'TRUE';
            }
            next;
        }

        my ($k, $v) = &parse_cueline($cuesheet[$i]);
        next unless $k;
        $v =~ s/\"/\\\"/g; # If there are any quotes in there, escape them
        if ($file >= 0) {
            $data->{FILE}->[$file]->{TRACKS}->[$track]->{$k} = $v;
        } else {
            $data->{$k} = $v;
        }
    }
    $data->{TOTAL_TRACKS} = $ttracks;
    return $data;
}

##########
sub parse_cueline {
    my ($line) = @_;
    $line =~ s/^[^0-9A-Za-z]*//; # remove all non alphanumerics from the start of the line.
    $line =~ s/^\s*//;
    $line =~ s/^REM //;
    $line =~ s/`/'/g; # bugfix: backticks break shell compatibility, so we squash them.
    
    return ($1, $2) if ($line =~ m/^(.*?) \"(.*)\".*?$/);
    return ($1, $2) if ($line =~ m/^(\w+?) (.+)/);
    return (undef, undef);
}

##########
sub sanitise_filename {
    my ($filename) = @_;
    $filename = "Unknown" unless defined $filename; # If an artist or title is missing, say it's unknown.
    $filename =~ s/[^[:ascii:]]/-/g; # Replace all non-ASCII characters
    $filename =~ s!/!-!g;
    $filename =~ s!\\!-!g;
    $filename =~ s!\"!-!g;
    $filename =~ s!:!-!g;
    $filename =~ s!\*!-!g;
    $filename =~ s!\?!!g;
    $filename =~ s!\.+$!!;
    $filename =~ s!\s+$!!;
    return $filename;
}

##########
sub fix_noncompliant {
    my @in = @_;
    my @out;
    my $i = 0;
    while ($i <= $#in) {
        my @track;
        push @track, $in[$i];
        $i++;
        while ($i <= $#in && $in[$i] !~ m/^\s*TRACK/ ) {
            if ($in[$i] =~ m/^\s*INDEX 00/ && $in[$i+1] =~ m/^\s*FILE/) {
                $in[$i] =~ s/INDEX 00/REM XGAP/;
                unshift @track, ($in[$i], $in[$i+1]);
                $i+=2;
            } else {
                push @track, $in[$i];
                $i++;
            }
        }
        push @out, @track;
    }
    return @out;
}

##########

1;
