#!/usr/bin/env perl
##########
# 
# MakeMP3
# 
# A tool for creating MP3 files from lossless full-disc rips with cue sheets.
# Copyright 2015-2022 Andrew Paul Landells.
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
# 
##########
use strict;
use warnings;
use Getopt::Long;
use Data::Dumper;
use Path::Class;
use JSON;

my $VER = '1.3.2';

$Data::Dumper::Sortkeys = 1;

##########
# option variables with default value (false)
my $HELP = '';
my $VERSION = '';
my $DRY_RUN = ''; 
my $DEBUG = ''; 
my $QUIET = '';
my $FORCE = '';
my $SORT = '';
my $GAIN = 'cue';
my $CFF = '';

GetOptions (
    'help'    => \$HELP,
    'version' => \$VERSION,
    'dry-run' => \$DRY_RUN,
    'debug'   => \$DEBUG,
    'quiet'   => \$QUIET,
    'force'   => \$FORCE,
    'sort'    => \$SORT,
    'gain=s'  => \$GAIN,
    'conf=s'  => \$CFF,
);

my $CONFIG = decode_json(do { local $/; <DATA> });

if ($CFF ne '') {
    open (my $CFH, '<'.$CFF) or die "Failed to open configuration file $CFF\n";
    my $newconf = decode_json(do { local $/; <$CFH> });
    close $CFH;
    if (defined ($newconf->{VERSION}) && $newconf->{VERSION} == 1) {
        $CONFIG = {%$CONFIG, %$newconf};
    } else {
        print "Unsupported configuration: $CFF\n";
    }
}

print Dumper $CONFIG if $DEBUG;

if ($VERSION) { print <<END;
MakeMP3 $VER
Copyright 2015-2022 Andrew Paul Landells

License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
END
; exit 0 }

if ($HELP) { print <<END;
Usage: $0 [--conf=config_file] [--gain=cue|album|track|none] [--debug] [--dry-run] [--force] [--sort] source_file ...
END
; exit 0 }

foreach my $cuefilename (@ARGV) {
    print "### $cuefilename\n";
    my $cuesheet = &parse_cuesheet($cuefilename);
    my $cuetime = &get_file_time($cuefilename);
    print "Failed to open $_\n" and next unless defined $cuesheet;

    unless ($QUIET) {
        print "$cuesheet->{PERFORMER} - " if defined $cuesheet->{PERFORMER};
        print "$cuesheet->{TITLE}" if defined $cuesheet->{TITLE};
        print ":\n";
    }

    my @tracks;
    for (my $file = 0 ; $file <= $#{$cuesheet->{FILE}} ; $file++) {
        for (my $track = 0 ; $track <= $#{$cuesheet->{FILE}->[$file]->{TRACKS}} ; $track++) {
            my $destpath = &build_dest_path($cuesheet);
            my $dest = file($destpath, &output_filename($cuesheet, $file, $track));
            my $nonce = sprintf "%08X\n", rand(0xffffffff);
            my $tempfile = "$dest.$nonce";
            my $ff  = &ffmpeg($cuesheet, $file, $track);
            #my $enc = &encoder($cuesheet, $file, $track, $tempfile);
            my $enc = &encoder($cuesheet, $file, $track, $dest);

            my $mp3time = &get_file_time($dest);
            next unless ($cuetime > $mp3time || $FORCE);

            print "... Track skipped!\n" and next if (&meta_validate("SKIP", $cuesheet, $file, $track) && !$QUIET);
            print "... $dest\n" unless $QUIET;

            &sys_cmd ("mkdir -p \"$destpath\"") ;
            &sys_cmd ("$ff | $enc");
            #&sys_cmd ("mv -f \"$tempfile\" \"$destpath\"") || next;

            push (@tracks, "\"$dest\"");
        }
    }

    my $gainword = $GAIN;
    $gainword  = lc($cuesheet->{GAIN}) if ($GAIN eq 'cue' && defined $cuesheet->{GAIN});
    &gain($gainword, @tracks);
}

##########
# Abstract out all system calls to a handler function that supports
# signal-handling. As a bonus, we can also collapse dryrun and debug
# behaviour to this one function.
#
# NB: Many commands will be invoked via a shell, rather than directly.
# This means the returncodes will be from bash, not the child process.
# As such, expect ^C to return an exit code of 130 but no evidence of a signal.
sub sys_cmd {
    my ($cmd) = @_;
    print "\tExecuting command: $cmd\n" if $DEBUG;
    $cmd .= " 2>&1 >/dev/null" unless $DEBUG;
    system ($cmd) unless $DRY_RUN;
    if ($?) {
        # We got back a returncode that wasn't zero...

        my $exit = $? >>  8; # Top eight bits are the return code
        my $core = $? & 128; # Bit 8 is core dump (true/false)
        my $kill = $? & 127; # Bits 1-7 are the kill signal received

        my $error = "!!! `$cmd`: exited with returncode $exit";
        $error   .= ", killed with signal $kill" if ($kill);
        $error   .= ", core dumped" if ($core);
        warn ($error);

        # If the child process was killed with a signal, we exit too.
        # We exit with a returncode of SIG+128, just like bash does.
        exit ($kill + 128) if ($kill); # The child process was killed.
        exit ($exit) if ($exit > 128 && $exit < 255); # A grandchild was killed, so bash told us.

        # If we died by some other means, return the exit status but keep going!
        return $exit;
    }
    # Otherwise everything was fine!
    return 0;
}

##########
# Run aacgain if we've been asked to.
sub gain {
    my ($gainword, @tracks) = @_;
    return unless ($gainword eq 'album' || $gainword eq 'track');
    my $gainopts;
    $gainopts  = "$CONFIG->{AAGOPTS}" if ($gainword eq 'album');
    $gainopts  = "$CONFIG->{ATGOPTS}" if ($gainword eq 'track');
    $gainopts .= " $CONFIG->{AGQUIET}" unless $DEBUG;
    my $gaincmd = "$CONFIG->{AACGAIN} $gainopts ".join (' ',@tracks);
    print "*** Applying $gainword gain\n";
    &sys_cmd ($gaincmd);
    return;
}

##########
# Work out which metadata function/variation to call, based on a prefix, then return the metadata.
sub metameta {
    my ($prefix, $field, $cuesheet, $file, $track) = @_;
    return &meta_validate($field, $cuesheet)                if ($prefix =~ /%%\?/);
    return &meta_override($field, $cuesheet)                if ($prefix =~ /%%/);
    return &meta_validate($field, $cuesheet, $file, $track) if ($prefix =~ /%\?/);
    return &meta_override($field, $cuesheet, $file, $track) if ($prefix =~ /%/);
    return undef;
}

##########
# Build the encoder command line to create the output file with metadata
sub encoder {
    my ($cuesheet, $file, $track, $dest) = @_;
    my $enc  = "$CONFIG->{ENCODER} $CONFIG->{ENCOPTS} ";
       $enc .= "$CONFIG->{ENQUIET} " unless $DEBUG;

    my @trackconfig = @{$CONFIG->{METADATA}};
    LOOP: foreach my $line (@trackconfig) {
        while ($line =~ m/(%%?\??)(\w+)/g) {
            my ($prefix, $field) = ($1, $2);
            my $metadata = &metameta($prefix, $field, $cuesheet, $file, $track);
            next LOOP unless (defined $metadata && $metadata ne '');
            $line =~ s/\Q$prefix$field\E/$metadata/;
        }
        $enc .= "$line ";
    }
    $enc .= "\"$dest\"";
    return $enc;
}

##########
# Build the ffmpeg command line to read the input data
sub ffmpeg {
    my ($cuesheet, $file, $track) = @_;
    my $src = file($cuesheet->{_CUEPATH}, $cuesheet->{FILE}->[$file]->{FILE});
    my $ff  = "$CONFIG->{FFMPEG} ";
       $ff .= "$CONFIG->{FFQUIET} " unless $DEBUG;
       $ff .= "-i \"$src\" ";
       $ff .= &get_ffmpegtimes($cuesheet, $file, $track).' ';
       $ff .= "$CONFIG->{FILTER} " if &meta_validate("_FLAGS_PRE", $cuesheet, $file, $track);
       $ff .= "$CONFIG->{FFOPTS} -";
    return $ff;
}

##########
# Build a destination path of the form BASEPATH/Artist/Album Title/
sub build_dest_path {
    my ($cuesheet) = @_;
    my $p = &sanitise_filename($cuesheet->{PERFORMER});
    my $t = &sanitise_filename($cuesheet->{TITLE});
    if ($SORT) {
        $p = &sort_filename(&sanitise_filename($cuesheet->{PERFORMER}));
        $t = &sort_filename(&sanitise_filename($cuesheet->{TITLE}));
    }
    return file($CONFIG->{DESTDIR}, $p, $t);
}

##########
# Take the path to the cuesheet and split it into path and file.
# If it's in the current directory, use ./ as the path.
sub split_path {
    my ($cuesheet) = @_;
    my ($cuepath, $cuefile);
    if ($cuesheet =~ m/^(.*)[\\\/](.*?)$/) {
        ($cuepath, $cuefile) = ($1, $2);
    } else {
        $cuepath = "./";
        $cuefile = $_;
    }
    print "Path: $cuepath\nFile: $cuefile\n\n" if $DEBUG;
    return ($cuepath, $cuefile);
}

##########
# Create the human-readable track number for filenames.
# For single-disc sets, this will be of the form 01, 02, 03 ...
# For multi-disc sets, this will be of the form 1-01, 1-02 ... 2-01, 2-02 ...
# If no track metadata exists, just do without a prefix.
sub output_filename {
    my ($cuesheet, $file, $track) = @_;
    my $tn = &meta_override("TRACK", $cuesheet, $file, $track);
    my $ofn = '';
    $ofn .= $cuesheet->{DISCNUMBER}."-" if (defined $cuesheet->{DISCNUMBER} && defined $cuesheet->{TOTALDISCS} && $cuesheet->{TOTALDISCS} > 1);
    $ofn .= sprintf("%.02d",$tn) if (defined $tn) && ($tn =~ m/^\d+$/);
    $ofn .= ' ' unless $ofn =~ m/^$/;
    $ofn .= &sanitise_filename(&meta_override("TITLE", $cuesheet, $file, $track));
    $ofn .= $CONFIG->{FILEEXT};
    return $ofn;
}

##########
# Wrapper to meta_override. Designed to test flags rather than return values.
# Has the same prototype as meta_override, i.e.:
# ($field, $cuesheet, $file, $track) = @_;
sub meta_validate {
    return 1 if &meta_override(@_) =~ /TRUE/i;
    return 0;
}

##########
sub meta_override {
    my ($field, $cuesheet, $file, $track) = @_;
    return $cuesheet->{FILE}->[$file]->{TRACKS}->[$track]->{$field} if (defined $file) and (defined $track) and (defined $cuesheet->{FILE}->[$file]->{TRACKS}->[$track]->{$field});
    return $cuesheet->{$field} if defined $cuesheet->{$field};
    return '';
}

##########
sub convert_time {
    # CD timestamps are of the form minutes:seconds:frames
    # where frames are 1/75th of a second.
    # ffmpeg timestamps are decimal seconds to arbitrary precision.
    my ($time) = @_;
    if (defined $time && $time =~ m/.*:.*:.*/) {
        my ($m, $s, $f) = split /:/,$time;
        return ($m * 60) + $s + ($f / 75);
    }
    return undef;
}

##########
sub get_time_index {
    my ($index, $cuesheet, $file, $track) = @_;
    if (defined $cuesheet->{FILE}->[$file]->{TRACKS}->[$track]) {
        return &convert_time($cuesheet->{FILE}->[$file]->{TRACKS}->[$track]->{INDEX}->[$index]);
    }
    return undef;
}

##########
sub get_ffmpegtimes {
    my ($cuesheet, $file, $track) = @_;
    my $this = &get_time_index(1, $cuesheet, $file, $track);
    my $stop = &convert_time($cuesheet->{FILE}->[$file]->{TRACKS}->[$track]->{END});
    my $next = &get_time_index(1, $cuesheet, $file, $track+1);
    my $ss = '';
    my $t  = '';
    if (defined $this) {
        $ss .= "-ss $this";
        if (defined $stop) {
            my $time = $stop - $this;
            $t .= "-t $time";
        } elsif (defined $next) {
            my $time = $next - $this;
            $t .= "-t $time";
        }
    }
    return ("$ss $t");
}

##########
# Get the UNIX timestamp of a file
sub get_file_time {
    my ($file) = @_;
    open(my $fh, "<".$file) or return 0;
    return (stat($fh))[9];
}

##########
sub parse_cuesheet {
    my ($cuesheet) = @_;
    # Cache the path to the cuesheet, since all the source files are relative to it.
    my ($cuepath, $cuefile) = &split_path($cuesheet);
    open(my $fh, "<".$cuesheet) or return undef;

    # Cache the last-modified timestamp of the cuesheet.
    my @cuesheet;
    while (<$fh>) {
        s/\r//g;
        s/\n//g;
        push @cuesheet, $_;
    }
    close ($fh);
    @cuesheet = &fix_noncompliant(@cuesheet);

    my $data = {};
    my $file = -1;
    my $track = -1;
    my $ttracks = 0;

    for (my $i = 0 ; $i <= $#cuesheet ; $i++) {
        if ($cuesheet[$i] =~ m/^\s*FILE "(.*)" (\w+)/) {
            $file++;

            print "\$file invalid!\n" unless $file>=0;

	    $data->{FILE}->[$file]->{FILE} = $1;
            $data->{FILE}->[$file]->{TYPE} = $2;
            $track = -1;
            next;
        }
        if ($cuesheet[$i] =~ m/^\s*TRACK/) {
            $track++;
            if ($cuesheet[$i] =~ m/(\d+) AUDIO/) {
		die "TRACK directive does not correspond to a FILE!\n" unless $data->{FILE};
		die "No current file!\n" unless $file>=0;

                $data->{FILE}->[$file]->{TRACKS}->[$track]->{TRACK} = $1;
                $ttracks = $1 if ($1 > $ttracks);
            }
            next;
        }
        if ($cuesheet[$i] =~ m/^\s*INDEX (\d+) (.*)$/) {
            next if $track < 0; # Dodgy cue sheets may cause -1 indices.

            print "\$file invalid!\n" unless $file>=0;
            print "\$data->{FILE} invalid!\n" unless $data->{FILE};
            print "\$data->{FILE}->[\$file] invalid!\n" unless $data->{FILE}->[$file];
            print "\$data->{FILE}->[\$file]->{TRACKS} invalid!\n" unless $data->{FILE}->[$file]->{TRACKS};
            print "\$data->{FILE}->[\$file]->{TRACKS}->[\$track] invalid!\n" unless $data->{FILE}->[$file]->{TRACKS}->[$track];

	    $data->{FILE}->[$file]->{TRACKS}->[$track]->{INDEX}->[$1] = $2;
            next;
        }
        if ($cuesheet[$i] =~ m/^\s*FLAGS (.*)/) {
            foreach my $flag (split /\s+/,$1) {
                print "\$file invalid!\n" unless $file>=0;
                print "\$track invalid!\n" unless $track>=0;
                print "\$flag invalid!\n" unless $flag;
                print "\$data->{FILE} invalid!\n" unless $data->{FILE};
                print "\$data->{FILE}->[\$file] invalid!\n" unless $data->{FILE}->[$file];
                print "\$data->{FILE}->[\$file]->{TRACKS} invalid!\n" unless $data->{FILE}->[$file]->{TRACKS};
                print "\$data->{FILE}->[\$file]->{TRACKS}->[\$track] invalid!\n" unless $data->{FILE}->[$file]->{TRACKS}->[$track];

                $data->{FILE}->[$file]->{TRACKS}->[$track]->{"_FLAGS_$flag"} = 'TRUE';
            }
            next;
        }

        my ($k, $v) = &parse_cueline($cuesheet[$i]);
        next unless $k;
        $v =~ s/\"/\\\"/g; # If there are any quotes in there, escape them
        next unless $k;
        if ($file >= 0 && $track >= 0) {
            print "\$k invalid!\n" unless $k;
            print "\$data->{FILE} invalid!\n" unless $data->{FILE};
            print "\$data->{FILE}->[\$file] invalid!\n" unless $data->{FILE}->[$file];
            print "\$data->{FILE}->[\$file]->{TRACKS} invalid!\n" unless $data->{FILE}->[$file]->{TRACKS};
            print "\$data->{FILE}->[\$file]->{TRACKS}->[\$track] invalid!\n" unless $data->{FILE}->[$file]->{TRACKS}->[$track];

            $data->{FILE}->[$file]->{TRACKS}->[$track]->{$k} = $v;
        } else {
            $data->{$k} = $v;
        }
    }

    # Define DISCNUMBER and TOTALDISCS if they're missing from the cue sheet.
    $data->{DISCNUMBER} = 1 unless defined $data->{DISCNUMBER};
    $data->{TOTALDISCS} = $data->{DISCNUMBER} unless defined $data->{TOTALDISCS};

    # Add extra data to the cuesheet so the metadata engine can recycle it.
    $data->{_TOTALTRACKS} = $ttracks;
    $data->{_VERSION} = "$VER";
    $data->{_CUEPATH} = $cuepath;
    $data->{_ENCOPTS} = $CONFIG->{ENCOPTS};
    $data->{_ENCODER} = $CONFIG->{ENCODER};
    $data->{_ENCODER} =~ s!^.*/!!;

    print Dumper $data if $DEBUG;
    return $data;
}

##########
sub parse_cueline {
    my ($line) = @_;
    $line =~ s/^[^0-9A-Za-z]*//; # remove all non alphanumerics from the start of the line.
    $line =~ s/^\s*//;
    $line =~ s/^REM //;
    $line =~ s/`/'/g; # bugfix: backticks break shell compatibility, so we squash them.
    
    return ($1, $2) if ($line =~ m/^(.*?) \"(.*)\".*?$/);
    return ($1, $2) if ($line =~ m/^(\w+?) (.+)/);
    return (undef, undef);
}

##########
sub sanitise_filename {
    my ($filename) = @_;
    $filename = "Unknown" unless defined $filename; # If an artist or title is missing, say it's unknown.
    $filename =~ s/[^[:ascii:]]/-/g; # Replace all non-ASCII characters
    $filename =~ s!<!_!g;
    $filename =~ s!>!_!g;
    $filename =~ s!/!-!g;
    $filename =~ s!\\!-!g;
    $filename =~ s!\"!-!g;
    $filename =~ s!:!-!g;
    $filename =~ s!\*!-!g;
    $filename =~ s!\?!!g;
    $filename =~ s!\.+$!!;
    $filename =~ s!\s+$!!;
    return $filename;
}

##########
sub sort_filename {
    my ($filename) = @_;
    if ($filename =~ m/^(The) (.*)$/){
        $filename = "$2, $1";
    } elsif ($filename =~ m/^(A) (.*)$/){
        $filename = "$2, $1";
    }
    return $filename;
}

##########
sub fix_noncompliant {
    my @in = @_;
    my @out;
    my $i = 0;
    while ($i <= $#in) {
        my @track;
        push @track, $in[$i];
        $i++;
        while ($i <= $#in && $in[$i] !~ m/^\s*TRACK/ ) {
            if ($in[$i] =~ m/^\s*FILE/ && $in[$i+1] =~ m/^\s*INDEX 01/) {
                unshift @track, $in[$i];
                push @track, ($in[$i+1]);
                $i+=2;
            } else {
                push @track, $in[$i];
                $i++;
            }
        }
        push @out, @track;
    }
    return @out;
}

##########
1;

__DATA__
{
    "DESTDIR"  : "makemp3",
    "FFMPEG"   : "ffmpeg -hide_banner",
    "FFQUIET"  : "-v warning",
    "FFOPTS"   : "-map 0:a -c:a pcm_s32le -f wav",
    "FILTER"   : "-af aemphasis=type=cd",
    "AACGAIN"  : "aacgain",
    "AGQUIET"  : "-q",
    "AAGOPTS"  : "-a -c",
    "ATGOPTS"  : "-r -c",
    "ENCODER"  : "lame",
    "ENQUIET"  : "--quiet",
    "ENCOPTS"  : "--preset extreme",
    "FILEEXT"  : ".mp3",
    "METADATA" : [
        "--tv TENC=\"MakeMP3 %_VERSION / %_ENCODER %_ENCOPTS\"",
        "--tn %TRACK/%_TOTALTRACKS",
        "--tv TPOS=%DISCNUMBER/%TOTALDISCS",
        "--tv TCMP=%?COMPILATION",
        "--tl \"%%TITLE\"",
        "--tv TPE2=\"%%PERFORMER\"",
        "--tt \"%TITLE\"",
        "--ta \"%PERFORMER\"",
        "--tg \"%GENRE\"",
        "--ty \"%DATE\"",
        "--tc \"%COMMENT\"",
        "--tv TCOM=\"%SONGWRITER\"",
        "--ti \"%_CUEPATH/%ARTWORK\"",
        "--id3v2-only --ignore-tag-errors - "
    ]
}
